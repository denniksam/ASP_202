@model ASP_202.Models.Home.Model

@{
    ViewData["Title"] = Model.Header;
}

<div class="text-center">
    <h1 class="display-4">@Model.Title</h1>
</div>

<p>
    У ASP.NET поняття моделі дещо відрізняється від класичного у
    паттерні MVC - це клас, об'єкт якого передається від контроллера до
    представлення - щось схоже на інтерфейс передачі даних.
</p>
<p>
    У папці Models додаємо папку з назвою контроллеру (Home)<br/>
    На початку .cshtml заявляемо тип моделі оператором &commat;model<br/>
    У контроллері при виклику View зазначаємо об'єкт моделі: <br />
    Далі у коді переданий об'єкт доступний за ключовим словом Model (для
    довільного класу моделей)
</p>
<p>
    Через модель передані дані про відділи:
</p>
<p>
    Д.З. Реалізувати виведення даних про товари, передані через модель,
    у вигляді HTML таблиці [№, Назва, Ціна] 
    (із заголовками, границями, *зеброю - різним фоном для парних та непарних рядків)
    (ціна округлена до копійок, якщо немає - .00 )
</p>

<h2>Шаблони відображення</h2>
<p>
    Відокремлення моделей, а також інших промімжних типів (на зразок Product)
    викликає питання уніфікації їх відображення. Для цього створюються шаблони
    відображення (display templates)
</p>
<p>
    Шаблони можуть автоматично зв'язуватись за збігом типу даних, або за 
    іменем шаблона. Шаблони відображення створюються у додатковій 
    папці DisplayTemplates у папках Views/[Controller]
</p>

@Html.DisplayFor(m => m.Products[0])

<p>
    Шаблон підключається за допомогою 
    <code>&commat;Html.DisplayFor(m => m.Products[0])</code>
    Пошук шаблона має відбуватись за назвою типу: 
    <code>m.Products[0]</code> має тип <code>Product</code>
    відповідно у DisplayTemplates буде шукатись файл Product.cshtml.
    Якщо назва типу складна (наприклад, колекція) або є проблеми з автоматичним
    пошуком, то назву шаблону можна зазначити другим параметром у виклику
    <code>&commat;Html.DisplayFor(m => m.Products[0], "Product")</code>
</p>

@Html.DisplayFor(m => m.Products, "Products")
